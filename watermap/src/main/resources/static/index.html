<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Water Bodies – Algae Bloom Index</title>

    <link rel="stylesheet"
          href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>

    <style>
        body {
            margin: 0;
            background-color: black;
        }
        #map {
            height: 100vh;
            width: 100%;
        }
    </style>
</head>
<body>

<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
/* =======================
   MAP INITIALIZATION
======================= */
const map = L.map('map').setView([40, -100], 4);

L.tileLayer(
    'https://{s}.basemaps.cartocdn.com/dark_nolabels/{z}/{x}/{y}{r}.png',
    {
        maxZoom: 19,
        attribution: '© OpenStreetMap contributors © CARTO'
    }
).addTo(map);

/* =======================
   UTILITIES
======================= */
function clamp(x, min, max) {
    return Math.max(min, Math.min(max, x));
}

/* =======================
   ABI CALCULATION
======================= */
function getABI(entry) {
    const temp = entry.temperature_c ?? entry.temp;

    const tempScore = clamp((+temp - 15) / 15, 0, 1);
    const turbScore = clamp(+entry.turbidity / 5, 0, 1);
    const tdsScore  = clamp(+entry.tds / 500, 0, 1);
    const pHScore   = clamp((+entry.pH - 7) / 2.5, 0, 1);

    return (
        0.35 * tempScore +
        0.30 * turbScore +
        0.20 * tdsScore +
        0.15 * pHScore
    );
}

/* =======================
   ABI → COLOR
======================= */
function abiToColor(abi) {
    const clamped = clamp(abi, 0, 1);
    const hue = (1 - clamped) * 270; // purple → red
    return `hsl(${hue}, 90%, 50%)`;
}

/* =======================
   ADD MARKER
======================= */
async function addMarker(entry) {
    const lat = +entry.lat;
    const lon = +entry.lon;

    // Optionally, check if water (placeholder)
    // const water = true; 
    // if (!water) return;

    const abi = +entry.abi ?? getABI(entry);
    const color = abiToColor(abi);
    const weight = +entry.weight ?? 1;

    // 10m x 10m square
    const half = 50; // meters
    const dLat = half / 111320;
    const dLon = half / (111320 * Math.cos(lat * Math.PI / 180));

    const bounds = [
        [lat - dLat, lon - dLon],
        [lat + dLat, lon + dLon]
    ];

    L.rectangle(bounds, {
        color: color,
        weight: weight,
        fillColor: color,
        fillOpacity: weight
    })
    .addTo(map)
    .bindPopup(`
        <b>Latitude:</b> ${lat}<br>
        <b>Longitude:</b> ${lon}<br>
        <b>ABI:</b> ${abi.toFixed(2)}<br>
        <b>Temperature:</b> ${+entry.temp} °C<br>
        <b>TDS:</b> ${+entry.tds} ppm<br>
        <b>Turbidity:</b> ${+entry.turbidity}<br>
        <b>pH:</b> ${+entry.pH}<br>
        <b>Timestamp:</b> ${entry.timestamp}<br>
        <b>Confidence:</b> ${+entry.weight}
    `);
}

/* =======================
   LOAD DATA
======================= */
async function loadPixels() {
    try {
        const backendURL = 'https://conradchallenge-production.up.railway.app';
        
        // Step 1: trigger processor on hosted backend
        const genResp = await fetch(`${backendURL}/generatePixels`);
        if (!genResp.ok) throw new Error('Failed to run processor');
        console.log("Processor ran successfully");

        // Step 2: fetch updated pixels JSON from hosted backend
        const dataResp = await fetch(`${backendURL}/data/pixels.json?t=${Date.now()}`);
        if (!dataResp.ok) throw new Error('Failed to fetch pixels.json');

        const json = await dataResp.json();

        for (const pixel of json.pixels) {
            await addMarker(pixel); // ensure sequential rendering
        }
    } catch (err) {
        console.error('Error loading pixels:', err);
    }
}

// Run on page load
window.onload = loadPixels;
</script>

</body>
</html>
